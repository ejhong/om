<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HM4DHK3XSL"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-HM4DHK3XSL');
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The OM Project</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <script src="om_audio_engine.js"></script>
  <script src="om_presets.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* Earth/Wabi-sabi palette */
      --bg: #faf7f2;           /* warm rice paper */
      --panel-bg: #2a2826;     /* ink stone charcoal */
      --accent: #9a8a78;       /* warm bronze */
      --accent-dark: #6b5d4d;  /* deep bronze */
      --text-primary: #3a3632; /* warm dark */
      --text-muted: #8a7d6d;   /* muted bronze */
      --border: #e0dbd4;       /* warm gray border */
      --frame-bg: #f0ebe4;     /* slightly darker paper */
      --frame-border: #c4bbb0; /* stone border */
      --frame-accent: #a89f94; /* stone accent */
      /* Voice colors - earth tones */
      --tlk-color: #90989e;    /* stone gray */
      --rap-color: #c87868;    /* terracotta */
      --ydl-color: #7ca67c;    /* sage */
      --sng-color: #a482ac;    /* dusty plum */
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Top Bar */
    .top-bar {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      padding: 12px 24px;
      border-bottom: 1px solid var(--border);
      background: var(--border);
      flex-shrink: 0;
    }

    .title {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    .subtitle-quote {
      font-family: Georgia, 'Times New Roman', serif;
      font-style: italic;
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 4px;
      line-height: 1.5;
      max-width: 600px;
    }

    .subtitle-quote .attribution {
      font-style: normal;
      font-size: 9px;
      opacity: 0.7;
    }

    /* Main Content */
    .main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
      min-height: 0;
      padding: 16px;
      gap: 16px;
    }

    /* Right Panel - Notes List (YouTube chat style) */
    .notes-panel {
      width: 250px;
      min-width: 250px;
      max-width: 250px;
      background: var(--panel-bg);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
    }

    .notes-panel-header {
      padding: 12px 16px;
      font-size: 12px;
      font-weight: 600;
      color: #c4b8a8;
      background: #232220;
      border-bottom: 1px solid #3a3836;
      flex-shrink: 0;
    }

    .notes-panel-content {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 8px 0;
      background: #3d3a36;
    }

    .segment-header {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      font-size: 11px;
      font-weight: 600;
      color: #c4b8a8;  /* warm sand - harmonizes with earth palette */
      padding: 12px 12px 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .note-item {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      font-size: 9px;
      padding: 3px 12px;
      color: #ffffff;
      cursor: pointer;
      transition: background 0.15s, opacity 0.15s;
      line-height: 1.4;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Intensity based on trajectory - inline styles set background */
    .note-item:hover {
      filter: brightness(1.3);
    }

    .note-item.playing {
      filter: brightness(1.5);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.5);
    }

    /* Visualization Canvas */
    .visualization {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--bg);
      min-width: 0;
      overflow: hidden;
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .canvas-container {
      flex: 1;
      position: relative;
      min-height: 0;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .canvas-overlay {
      position: absolute;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 10;
    }

    .canvas-overlay .preset-select {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      font-size: 10px;
      padding: 2px 6px;
      border: 1px solid var(--border);
      border-radius: 3px;
      background: var(--bg);
      color: var(--text-primary);
      cursor: pointer;
      outline: none;
    }

    /* Player Controls Bar (YouTube style - at bottom of video) */
    .player-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 16px 8px 16px;
      background: var(--frame-bg);
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }

    /* Rendering indicator */
    .rendering-indicator {
      display: none;
      align-items: center;
      gap: 8px;
      padding: 4px 12px;
      background: var(--accent);
      color: white;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }

    .rendering-indicator.active {
      display: flex;
    }

    .rendering-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Settings popup */
    .settings-container {
      position: relative;
    }

    .settings-btn {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 6px;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, color 0.2s;
    }

    .settings-btn:hover {
      background: var(--border);
      color: var(--text-primary);
    }

    .settings-btn svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    .settings-popup {
      position: absolute;
      bottom: 100%;
      right: 0;
      margin-bottom: 8px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      display: none;
      flex-direction: column;
      gap: 12px;
      min-width: 200px;
      z-index: 100;
    }

    .settings-popup.open {
      display: flex;
    }

    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .settings-row label {
      font-size: 12px;
      color: var(--text-muted);
      min-width: 50px;
    }

    .settings-row select,
    .preset-select,
    .speed-select {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      font-size: 12px;
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text-primary);
      cursor: pointer;
      outline: none;
    }

    .volume-slider,
    .tuning-slider {
      width: 100px;
      height: 4px;
      -webkit-appearance: none;
      background: var(--border);
      border-radius: 2px;
      outline: none;
    }

    .volume-slider::-webkit-slider-thumb,
    .tuning-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent-dark);
      border-radius: 50%;
      cursor: pointer;
    }

    .play-btn {
      width: 36px;
      height: 36px;
      border: none;
      border-radius: 50%;
      background: var(--accent-dark);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, transform 0.1s;
      flex-shrink: 0;
    }

    .play-btn:hover {
      background: var(--accent);
    }

    .play-btn:active {
      transform: scale(0.95);
    }

    .play-btn svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
    }

    .timeline-container {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .timeline {
      flex: 1;
      height: 6px;
      background: var(--frame-border);
      border-radius: 3px;
      cursor: pointer;
      position: relative;
      overflow: visible;
    }

    .timeline-progress {
      height: 100%;
      background: var(--accent);
      border-radius: 3px;
      width: 0%;
      transition: width 0.05s linear;
    }

    .timeline-handle {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 14px;
      height: 14px;
      background: var(--accent-dark);
      border-radius: 50%;
      cursor: grab;
      opacity: 1;
      transition: opacity 0.2s;
    }

    .timeline-handle:active {
      cursor: grabbing;
    }

    .time-display {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      font-size: 12px;
      color: var(--text-muted);
      min-width: 80px;
      flex-shrink: 0;
    }

    .speed-select {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      font-size: 13px;
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg);
      color: var(--text-primary);
      cursor: pointer;
      outline: none;
      flex-shrink: 0;
      transition: border-color 0.2s;
    }

    .speed-select:hover {
      border-color: var(--accent);
    }

    /* Segment markers on timeline */
    .segment-marker {
      position: absolute;
      top: -8px;
      width: 1px;
      height: 22px;
      background: var(--frame-border);
      pointer-events: none;
    }

    .segment-marker::after {
      content: attr(data-label);
      position: absolute;
      top: -16px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      font-size: 9px;
      color: var(--text-muted);
    }

    /* Scrollbar styling */
    .notes-panel-content::-webkit-scrollbar {
      width: 6px;
    }

    .notes-panel-content::-webkit-scrollbar-track {
      background: transparent;
    }

    .notes-panel-content::-webkit-scrollbar-thumb {
      background: #4a4644;
      border-radius: 3px;
    }

    .notes-panel-content::-webkit-scrollbar-thumb:hover {
      background: #5a5654;
    }

    /* Mobile responsive */
    @media (max-width: 768px) {
      body {
        height: auto;
        min-height: 100vh;
        overflow-y: auto;
      }

      .top-bar {
        padding: 6px 12px;
      }

      .title {
        font-size: 14px;
      }

      .main-content {
        flex-direction: column;
        padding: 8px;
        gap: 8px;
      }

      /* Graph area - fixed height */
      .visualization {
        flex: none;
        width: 100%;
      }

      .canvas-container {
        flex: none;
        height: 200px;
      }

      /* Notes panel - taller on mobile */
      .notes-panel {
        width: 100%;
        min-width: unset;
        max-width: unset;
        height: 540px;
        flex-shrink: 0;
      }

      .notes-panel-content {
        padding-bottom: 20px;
        -webkit-overflow-scrolling: touch;
      }

      .player-controls {
        padding: 20px 12px 8px 12px;
        gap: 8px;
      }

      .play-btn {
        width: 36px;
        height: 36px;
      }

      .time-display {
        display: none;
      }

      .settings-popup {
        right: 0;
        left: auto;
      }
    }
  </style>
</head>
<body>
  <!-- Top Bar -->
  <div class="top-bar">
    <div class="title">The OM Project</div>
    <div class="subtitle-quote">
      "Om is this imperishable word. Om is the universe, and this is the exposition of Om. The past, the present, and the future—all that was, all that is, all that will be—is Om. And whatever lies beyond in eternity, that too is Om."
      <span class="attribution">— Mandukya Upanishad</span>
    </div>
  </div>

  <!-- Main Content -->
  <div class="main-content">
    <!-- Visualization (YouTube video style) -->
    <div class="visualization">
      <div class="canvas-container">
        <canvas id="canvas"></canvas>
        <div class="canvas-overlay">
          <select class="preset-select" id="presetSelect">
            <option value="smad">smad</option>
            <option value="nndl">nndl</option>
            <option value="grat">grat</option>
            <option value="meta">meta</option>
          </select>
        </div>
      </div>
      <!-- Player Controls Bar (YouTube style) -->
      <div class="player-controls">
        <button class="play-btn" id="playBtn">
          <svg viewBox="0 0 24 24" id="playIcon">
            <path d="M8 5v14l11-7z"/>
          </svg>
        </button>
        <div class="rendering-indicator" id="renderingIndicator">
          <div class="rendering-spinner"></div>
          <span>Rendering...</span>
        </div>
        <div class="timeline-container">
          <div class="timeline" id="timeline">
            <div class="timeline-progress" id="timelineProgress"></div>
            <div class="timeline-handle" id="timelineHandle"></div>
          </div>
          <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
        </div>
        <!-- Settings gear -->
        <div class="settings-container">
          <button class="settings-btn" id="settingsBtn">
            <svg viewBox="0 0 24 24">
              <path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
            </svg>
          </button>
          <div class="settings-popup" id="settingsPopup">
            <div class="settings-row">
              <label>Vol</label>
              <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="75">
            </div>
            <div class="settings-row">
              <label>Tune</label>
              <input type="range" class="tuning-slider" id="tuningSlider" min="-6" max="6" value="0" step="0.1">
            </div>
            <div class="settings-row">
              <label>Speed</label>
              <select class="speed-select" id="speedSelect">
                <option value="0.5">0.5x</option>
                <option value="0.75">0.75x</option>
                <option value="1" selected>1x</option>
                <option value="1.5">1.5x</option>
                <option value="2">2x</option>
              </select>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Notes Panel (YouTube chat style) -->
    <div class="notes-panel" id="notesPanel">
      <div class="notes-panel-header">Notes</div>
      <div class="notes-panel-content" id="notesPanelContent">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>

  <script>
    // ========== POLYFILLS ==========
    // roundRect polyfill for older browsers (iOS Safari < 16)
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        if (typeof r === 'number') r = [r, r, r, r];
        const [tl, tr, br, bl] = r;
        this.moveTo(x + tl, y);
        this.lineTo(x + w - tr, y);
        this.arcTo(x + w, y, x + w, y + tr, tr);
        this.lineTo(x + w, y + h - br);
        this.arcTo(x + w, y + h, x + w - br, y + h, br);
        this.lineTo(x + bl, y + h);
        this.arcTo(x, y + h, x, y + h - bl, bl);
        this.lineTo(x, y + tl);
        this.arcTo(x, y, x + tl, y, tl);
        this.closePath();
      };
    }

    // ========== OM PRESETS loaded from om_presets.js ==========

    // Voice type colors (Earth/Wabi-sabi palette)
    const VOICE_COLORS = {
      'tlk': '#90989e',  // stone gray - talking
      'rap': '#c87868',  // terracotta - rap
      'ydl': '#7ca67c',  // sage green - yodel
      'sng': '#a482ac'   // dusty plum - singing
    };

    // ========== STATE ==========
    let parsedGroups = {};
    let allNotes = [];
    let isPlaying = false;
    let currentNoteIndex = 0;
    let playbackTimeout = null;
    let baseDuration = OM_DEFAULTS.duration;
    let playbackSpeed = 1;
    let startTime = 0;
    let pausedAt = 0;
    let playedSegments = [];
    let volume = OM_DEFAULTS.defaultVolume; // dB
    let masterVolume = null;

    // Offline audio player for pre-rendered audio (disabled for now - too slow)
    const USE_OFFLINE_RENDERING = false;
    const offlinePlayer = new OMOfflinePlayer();
    let needsRender = true; // Flag to track if audio needs re-rendering

    // ========== AUDIO UNLOCK FOR MOBILE ==========
    let audioUnlocked = false;
    async function unlockAudio() {
      if (audioUnlocked) return;
      try {
        await Tone.start();
        // Also resume AudioContext if suspended
        if (Tone.context.state !== 'running') {
          await Tone.context.resume();
        }
        audioUnlocked = true;
        console.log('Audio unlocked');
      } catch (e) {
        console.error('Audio unlock failed:', e);
      }
    }
    // Unlock on any user interaction
    ['touchstart', 'touchend', 'click'].forEach(event => {
      document.addEventListener(event, unlockAudio, { once: false, passive: true });
    });

    // ========== PARSING (uses om_audio_engine.js) ==========
    // parseVoiceSpec and parseOMInput are loaded from om_audio_engine.js

    // ========== OFFLINE AUDIO RENDERING ==========
    // Set up offline player callbacks
    offlinePlayer.onRenderStart = () => {
      document.getElementById('renderingIndicator').classList.add('active');
      document.getElementById('playBtn').disabled = true;
    };

    offlinePlayer.onRenderComplete = () => {
      document.getElementById('renderingIndicator').classList.remove('active');
      document.getElementById('playBtn').disabled = false;
      needsRender = false;
    };

    offlinePlayer.onProgress = (currentTime, noteIndex) => {
      currentNoteIndex = noteIndex;
      playedSegments = allNotes.slice(0, noteIndex + 1).map((n, idx) => ({ note: n, index: idx }));

      // Update note highlighting
      document.querySelectorAll('.note-item.playing').forEach(el => el.classList.remove('playing'));
      const noteItem = document.querySelector(`.note-item[data-index="${noteIndex}"]`);
      if (noteItem) {
        noteItem.classList.add('playing');
        scrollNoteIntoView(noteItem, playbackSpeed <= 1);
      }

      updateTimeline();
      drawVisualization();
    };

    offlinePlayer.onPlaybackEnd = () => {
      finishPlayback();
    };

    // Render audio with current settings
    async function renderAudio() {
      if (allNotes.length === 0) return;

      const totalDuration = baseDuration / playbackSpeed;
      await offlinePlayer.render(allNotes, totalDuration, {
        volumeDb: volume,
        overlapRatio: OM_DEFAULTS.overlapRatio
      });
    }

    // Mark that render is needed (called when settings change)
    function invalidateRender() {
      needsRender = true;
    }

    // ========== SETTINGS POPUP ==========
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsPopup = document.getElementById('settingsPopup');

    settingsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      settingsPopup.classList.toggle('open');
    });

    // Close popup when clicking outside
    document.addEventListener('click', (e) => {
      if (!settingsPopup.contains(e.target) && e.target !== settingsBtn) {
        settingsPopup.classList.remove('open');
      }
    });

    // ========== NOTES PANEL ==========
    // Scroll note into view only when it goes off screen (page-style scrolling)
    function scrollNoteIntoView(noteItem, smooth = false) {
      const container = document.getElementById('notesPanelContent');
      if (!container || !noteItem) return;
      const containerRect = container.getBoundingClientRect();
      const itemRect = noteItem.getBoundingClientRect();

      // Check if note is visible within container
      const isAbove = itemRect.top < containerRect.top;
      const isBelow = itemRect.bottom > containerRect.bottom;

      // Only scroll if note is off screen
      if (isAbove || isBelow) {
        const relativeTop = itemRect.top - containerRect.top + container.scrollTop;
        // Scroll to put note near top of container with padding
        const targetScroll = relativeTop - 20;
        container.scrollTo({ top: targetScroll, behavior: 'auto' });
      }
    }

    function renderNotesPanel() {
      const panel = document.getElementById('notesPanelContent');
      panel.innerHTML = '';

      const groupOrder = ['A1', 'A2', 'A3', 'A4', 'U1', 'U2', 'M1', 'M2'];
      let noteIndex = 0;

      for (const groupName of groupOrder) {
        if (!parsedGroups[groupName]) continue;
        const notes = parsedGroups[groupName];

        const header = document.createElement('div');
        header.className = 'segment-header';
        header.textContent = `${groupName} (${notes.length})`;
        panel.appendChild(header);

        for (const note of notes) {
          const item = document.createElement('div');
          item.className = 'note-item';
          item.dataset.index = noteIndex;

          // Bright colors for each voice type
          const voiceColors = {
            tlk: '#a0a8b0',  // light stone
            rap: '#e0a090',  // light terracotta
            ydl: '#90c090',  // light sage
            sng: '#c0a0d0'   // light plum
          };

          item.style.color = voiceColors[note.voiceType] || voiceColors.tlk;

          const trajStr = note.trajStart >= 0 ? `+${note.trajStart.toFixed(2)}` : note.trajStart.toFixed(2);
          const freqStr = note.frequency.toFixed(2);

          const scaleStr = String(note.scaleIndex).padStart(2, '0');
          item.textContent = `${note.voiceType}_${note.mode}/${note.register}/${note.articulation}/${note.keyNote}+${scaleStr}=${note.noteName}:${trajStr} ${freqStr}Hz`;

          item.addEventListener('click', () => playSingleNote(note));
          panel.appendChild(item);
          noteIndex++;
        }
      }
    }

    // ========== AUDIO (uses om_audio_engine.js) ==========
    let currentSynthObj = null;

    // Single note playback (for clicking on notes)
    async function playSingleNote(note) {
      try {
        await Tone.start();
        if (currentSynthObj) {
          const prev = currentSynthObj;
          currentSynthObj = null;
          try {
            const releaseTime = Math.max(0.05, prev.synth?.envelope?.release ?? 0.3);
            prev.synth.triggerRelease(Tone.now());
            setTimeout(() => { try { prev.dispose(); } catch(e) {} }, (releaseTime + 0.05) * 1000);
          } catch(e) {
            try { prev.dispose(); } catch(e) {}
          }
        }
        const duration = Math.max(0.5, (baseDuration / Math.max(1, allNotes.length)) / playbackSpeed);
        // Single click is 6dB quieter to match perceived playback level (playback has overlapping notes)
        currentSynthObj = createSynth(note, volume - 6);
        // Ignore section volume for single note clicks - always audible
        const trajMag = Math.max(Math.abs(note.trajStart || 0), Math.abs(note.trajEnd || 0));
        const clickVelocity = Math.max(0.1, Math.min(1, 0.6 + trajMag * 0.2));
        currentSynthObj.synth.triggerAttackRelease(note.startFrequency, duration, undefined, clickVelocity);
      } catch (e) {
        console.error('Audio error:', e);
      }
    }

    // ========== VISUALIZATION ==========
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      const container = document.querySelector('.canvas-container');
      const rect = container.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);

      drawVisualization();
      positionOverlay();
    }

    function positionOverlay() {
      const container = document.querySelector('.canvas-container');
      const rect = container.getBoundingClientRect();
      const canvasWidth = rect.width;
      const canvasHeight = rect.height;

      // Same calculations as drawVisualization
      const padding = 40;
      const maxGraphHeight = 200;
      const aspectRatio = 4;
      let graphWidth = canvasWidth - 2 * padding;
      let graphHeight = graphWidth / aspectRatio;
      if (graphHeight > maxGraphHeight) {
        graphHeight = maxGraphHeight;
        graphWidth = graphHeight * aspectRatio;
      }
      if (graphHeight > canvasHeight - 2 * padding - 30) {
        graphHeight = canvasHeight - 2 * padding - 30;
        graphWidth = graphHeight * aspectRatio;
      }
      const offsetX = (canvasWidth - graphWidth) / 2;
      const offsetY = (canvasHeight - graphHeight) / 2 - 10;
      const framePadding = 20;
      const frameTopPadding = 20;
      const frameX = offsetX - framePadding;
      const frameY = offsetY - frameTopPadding;

      const overlay = document.querySelector('.canvas-overlay');
      overlay.style.left = (frameX + 8) + 'px';
      overlay.style.top = (frameY - 25) + 'px';
    }

    function trajectoryToY(traj, height, padding) {
      const minTraj = -0.8;
      const maxTraj = 0.2;
      const range = maxTraj - minTraj;
      // Invert: high trajectory = top of canvas (low Y), low trajectory = bottom
      const normalized = (maxTraj - traj) / range;
      return padding + normalized * (height - 2 * padding);
    }

    function drawVisualization() {
      const container = document.querySelector('.canvas-container');
      const rect = container.getBoundingClientRect();
      const canvasWidth = rect.width;
      const canvasHeight = rect.height;

      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      if (allNotes.length === 0) {
        ctx.fillStyle = '#8a7d6d';  // muted bronze
        ctx.font = '14px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Select a preset to begin', canvasWidth / 2, canvasHeight / 2);
        return;
      }

      // Fixed aspect ratio for graph (width:height = 4:1, max height 200px)
      const maxGraphHeight = 200;
      const aspectRatio = 4;
      const padding = 40;

      // Calculate graph dimensions
      let graphWidth = canvasWidth - 2 * padding;
      let graphHeight = graphWidth / aspectRatio;

      // Clamp to max height
      if (graphHeight > maxGraphHeight) {
        graphHeight = maxGraphHeight;
        graphWidth = graphHeight * aspectRatio;
      }

      // Also ensure it fits in available canvas height
      if (graphHeight > canvasHeight - 2 * padding - 30) {
        graphHeight = canvasHeight - 2 * padding - 30;
        graphWidth = graphHeight * aspectRatio;
      }

      // Center the graph in the canvas
      const offsetX = (canvasWidth - graphWidth) / 2;
      const offsetY = (canvasHeight - graphHeight) / 2 - 10; // shift down to add more space above Hz/legend

      // Helper to convert trajectory to Y within graph bounds
      const graphTrajectoryToY = (traj) => {
        const minTraj = -0.8;
        const maxTraj = 0.8;  // symmetric around C (0)
        const range = maxTraj - minTraj;
        const normalized = (maxTraj - traj) / range;
        return offsetY + normalized * graphHeight;
      };

      // Draw decorative frame around graph area
      const framePadding = 20;
      const frameTopPadding = 20; // same as sides
      const frameX = offsetX - framePadding;
      const frameY = offsetY - frameTopPadding;
      const frameW = graphWidth + framePadding * 2;
      const frameH = graphHeight + frameTopPadding + framePadding + 30; // extra for labels

      // Subtle inner background
      ctx.fillStyle = '#f0ebe4';  // warm paper
      ctx.beginPath();
      ctx.roundRect(frameX, frameY, frameW, frameH, 8);
      ctx.fill();

      // Frame border
      ctx.strokeStyle = '#c4bbb0';  // stone border
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(frameX, frameY, frameW, frameH, 8);
      ctx.stroke();

      // Corner accents
      const accentSize = 12;
      ctx.strokeStyle = '#a89f94';  // stone accent
      ctx.lineWidth = 2;
      // Top-left
      ctx.beginPath();
      ctx.moveTo(frameX + 4, frameY + accentSize);
      ctx.lineTo(frameX + 4, frameY + 4);
      ctx.lineTo(frameX + accentSize, frameY + 4);
      ctx.stroke();
      // Top-right
      ctx.beginPath();
      ctx.moveTo(frameX + frameW - accentSize, frameY + 4);
      ctx.lineTo(frameX + frameW - 4, frameY + 4);
      ctx.lineTo(frameX + frameW - 4, frameY + accentSize);
      ctx.stroke();
      // Bottom-left
      ctx.beginPath();
      ctx.moveTo(frameX + 4, frameY + frameH - accentSize);
      ctx.lineTo(frameX + 4, frameY + frameH - 4);
      ctx.lineTo(frameX + accentSize, frameY + frameH - 4);
      ctx.stroke();
      // Bottom-right
      ctx.beginPath();
      ctx.moveTo(frameX + frameW - accentSize, frameY + frameH - 4);
      ctx.lineTo(frameX + frameW - 4, frameY + frameH - 4);
      ctx.lineTo(frameX + frameW - 4, frameY + frameH - accentSize);
      ctx.stroke();

      // Draw baseline C (trajectory = 0) - solid line
      const baselineY = graphTrajectoryToY(0);
      ctx.strokeStyle = '#6b5d4d';  // deep bronze
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(offsetX, baselineY);
      ctx.lineTo(offsetX + graphWidth, baselineY);
      ctx.stroke();

      // Label for baseline (different color from lines)
      ctx.fillStyle = '#8a7d6d';  // muted bronze
      ctx.font = '10px SF Mono, Monaco, monospace';
      ctx.textAlign = 'right';
      ctx.fillText('C', offsetX - 8, baselineY + 3);

      // Draw scale index as bar chart at bottom of frame
      const barMaxHeight = 35;  // max bar height for scaleIndex=15
      const barChartBase = offsetY + graphHeight + 5 + barMaxHeight;  // bottom baseline

      for (let i = 0; i < allNotes.length; i++) {
        const note = allNotes[i];
        const scaleIndex = note.scaleIndex !== undefined ? note.scaleIndex : 0;
        const isCurrentNote = (isPlaying || hasSeeked) && i === currentNoteIndex;

        const barHeight = ((15 - scaleIndex) / 15) * barMaxHeight;
        const barX = offsetX + (i / Math.max(1, allNotes.length - 1)) * graphWidth;

        // Draw bar growing up from baseline
        const barColor = VOICE_COLORS[note.voiceType] || '#8a7d6d';
        ctx.strokeStyle = barColor;
        ctx.globalAlpha = isCurrentNote ? 1.0 : 0.35;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(barX, barChartBase);
        ctx.lineTo(barX, barChartBase - barHeight);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Draw tension line curve with smooth bezier interpolation
      // Get Y-line (tension) notes - those with non-zero trajectory
      let tensionNotesWithIndex = allNotes
        .map((n, idx) => ({ note: n, index: idx }))
        .filter(item => item.note.trajStart !== 0);

      if (tensionNotesWithIndex.length > 1) {
        // Get points for the curve using actual positions in allNotes
        const points = tensionNotesWithIndex.map(item => ({
          x: offsetX + (item.index / Math.max(1, allNotes.length - 1)) * graphWidth,
          y: graphTrajectoryToY(item.note.trajStart)
        }));

        ctx.strokeStyle = '#6b5d4d';  // deep bronze
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);

        // Draw smooth curve using quadratic bezier through points
        for (let i = 0; i < points.length - 1; i++) {
          const p0 = points[i];
          const p1 = points[i + 1];

          if (i === 0) {
            // First segment: just curve toward midpoint
            const midX = (p0.x + p1.x) / 2;
            const midY = (p0.y + p1.y) / 2;
            ctx.quadraticCurveTo(p0.x + (p1.x - p0.x) * 0.5, p0.y, midX, midY);
          } else if (i === points.length - 2) {
            // Last segment: curve to end
            ctx.quadraticCurveTo(p0.x + (p1.x - p0.x) * 0.5, p1.y, p1.x, p1.y);
          } else {
            // Middle segments: smooth curve through midpoints
            const midX = (p0.x + p1.x) / 2;
            const midY = (p0.y + p1.y) / 2;
            ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);
          }
        }
        ctx.stroke();
      }

      // Draw all notes (always visible, highlight current)
      const segmentWidth = Math.max(4, graphWidth / allNotes.length);
      for (let i = 0; i < allNotes.length; i++) {
        const note = allNotes[i];
        const isCurrentNote = (isPlaying || hasSeeked) && i === currentNoteIndex;

        // Use original color, just brighter opacity for current note
        const color = VOICE_COLORS[note.voiceType] || '#8a7d6d';

        ctx.fillStyle = color;
        ctx.globalAlpha = isCurrentNote ? 1.0 : 0.7;

        const x = offsetX + (i / Math.max(1, allNotes.length - 1)) * graphWidth;
        const y = graphTrajectoryToY(note.trajStart);

        if (note.articulation === 'vbr') {
          // Vibrato notes as circles
          ctx.beginPath();
          ctx.arc(x, y, 4, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Solid notes as rectangles
          ctx.fillRect(x - segmentWidth/2, y - 4, segmentWidth, 8);
        }

        ctx.globalAlpha = 1;
      }

      // Draw current position indicator
      if ((isPlaying || hasSeeked) && currentNoteIndex < allNotes.length) {
        const x = offsetX + (currentNoteIndex / Math.max(1, allNotes.length - 1)) * graphWidth;
        ctx.strokeStyle = '#9a8a78';  // warm bronze
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, offsetY - 10);
        ctx.lineTo(x, offsetY + graphHeight + 10);
        ctx.stroke();
      }

      // Draw segment labels (muted bronze)
      ctx.fillStyle = '#8a7d6d';
      ctx.font = '9px SF Mono, Monaco, monospace';
      ctx.textAlign = 'center';

      const segments = ['A1', 'A2', 'A3', 'A4', 'U1', 'U2', 'M1', 'M2'];
      let noteCount = 0;
      const maxIdx = Math.max(1, allNotes.length - 1);
      ctx.textAlign = 'left';
      for (const seg of segments) {
        if (parsedGroups[seg]) {
          const x = offsetX + (noteCount / maxIdx) * graphWidth;
          ctx.fillText(seg, x, offsetY + 5);
          noteCount += parsedGroups[seg].length;
        }
      }

      // Hz display above frame (offset right to make room for preset dropdown)
      const tuning = getTuning();
      const baseHz = 261.63 * Math.pow(2, tuning / 12);
      ctx.font = '10px SF Mono, Monaco, monospace';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#8a7d6d';
      ctx.fillText(baseHz.toFixed(1) + ' Hz', frameX + 72, frameY - 11);

      // Voice color legend above top right corner of frame
      const legendItems = [
        { color: '#90989e', label: 'tlk' },
        { color: '#c87868', label: 'rap' },
        { color: '#7ca67c', label: 'ydl' },
        { color: '#a482ac', label: 'sng' }
      ];
      const itemWidth = 50;
      const dotWidth = 20;
      const dotHeight = 10;
      const legendWidth = legendItems.length * itemWidth;
      let legendX = frameX + frameW - legendWidth;
      const legendY = frameY - 12;

      ctx.textAlign = 'left';
      for (const item of legendItems) {
        // Draw color dot
        ctx.fillStyle = item.color;
        ctx.beginPath();
        ctx.roundRect(legendX, legendY - dotHeight + 3, dotWidth, dotHeight, 2);
        ctx.fill();
        // Draw label
        ctx.fillStyle = '#8a7d6d';
        ctx.fillText(item.label, legendX + dotWidth + 4, legendY + 3);
        legendX += itemWidth;
      }

      // Copyright below frame, bottom right
      ctx.fillStyle = '#a09990';
      ctx.font = '9px SF Mono, Monaco, monospace';
      ctx.textAlign = 'right';
      ctx.fillText('© 2026 Eugene Jhong', frameX + frameW - 8, frameY + frameH + 12);
    }

    // ========== PLAYBACK ==========
    function updateTimeDisplay() {
      const totalDuration = baseDuration / playbackSpeed;
      const currentTime = isPlaying ?
        (Date.now() - startTime) / 1000 :
        pausedAt / 1000;

      const formatTime = (s) => {
        const mins = Math.floor(s / 60);
        const secs = Math.floor(s % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      document.getElementById('timeDisplay').textContent =
        `${formatTime(Math.min(currentTime, totalDuration))} / ${formatTime(totalDuration)}`;
    }

    function updateTimeline() {
      const progress = currentNoteIndex / allNotes.length * 100;
      document.getElementById('timelineProgress').style.width = `${progress}%`;
      document.getElementById('timelineHandle').style.left = `${progress}%`;
    }

    async function startPlayback() {
      if (allNotes.length === 0) return;

      await Tone.start();

      // Always start from beginning
      currentNoteIndex = 0;
      playedSegments = [];
      if (USE_OFFLINE_RENDERING) offlinePlayer.stop();

      const startIndex = currentNoteIndex;
      isPlaying = true;
      startTime = Date.now();

      // Scroll to current note
      const startNoteItem = document.querySelector(`.note-item[data-index="${startIndex}"]`);
      if (startNoteItem) {
        scrollNoteIntoView(startNoteItem, false);
      }

      // Highlight starting note
      document.querySelectorAll('.note-item.playing').forEach(el => el.classList.remove('playing'));
      if (startNoteItem) startNoteItem.classList.add('playing');

      document.getElementById('playIcon').innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';

      const totalDuration = baseDuration / playbackSpeed;

      if (USE_OFFLINE_RENDERING) {
        // Offline mode: render if needed, then play buffer
        if (needsRender) {
          await renderAudio();
        }
        const seekTime = (startIndex / allNotes.length) * totalDuration;
        offlinePlayer.play(seekTime);
      } else {
        // Real-time mode: schedule notes with Transport
        Tone.Transport.stop();
        Tone.Transport.cancel();
        Tone.Transport.position = 0;

        const noteCount = allNotes.length;
        const noteDuration = totalDuration / noteCount;
        const noteSoundDuration = noteDuration * OM_DEFAULTS.overlapRatio;

        for (let i = startIndex; i < noteCount; i++) {
          const note = allNotes[i];
          const noteTime = (i - startIndex) * noteDuration;

          Tone.Transport.schedule((time) => {
            playNoteScheduled(note, noteSoundDuration, time, volume);

            Tone.Draw.schedule(() => {
              currentNoteIndex = i;
              playedSegments = allNotes.slice(0, i + 1).map((n, idx) => ({ note: n, index: idx }));

              document.querySelectorAll('.note-item.playing').forEach(el => el.classList.remove('playing'));
              const noteItem = document.querySelector(`.note-item[data-index="${i}"]`);
              if (noteItem) {
                noteItem.classList.add('playing');
                scrollNoteIntoView(noteItem, playbackSpeed <= 1);
              }

              updateTimeline();
              drawVisualization();
            }, time);
          }, noteTime);
        }

        Tone.Transport.start();

        const remainingDuration = (noteCount - startIndex) * noteDuration;
        if (playbackTimeout) clearTimeout(playbackTimeout);
        playbackTimeout = setTimeout(() => {
          if (isPlaying) finishPlayback();
        }, (remainingDuration + 1) * 1000);
      }
    }

    function finishPlayback() {
      // Stop playback but preserve the visualization
      isPlaying = false;
      if (playbackTimeout) {
        clearTimeout(playbackTimeout);
        playbackTimeout = null;
      }

      if (!USE_OFFLINE_RENDERING) {
        Tone.Transport.stop();
        Tone.Transport.cancel();
        Tone.Transport.position = 0;
      }

      document.getElementById('playIcon').innerHTML = '<path d="M8 5v14l11-7z"/>';
      document.querySelectorAll('.note-item.playing').forEach(el => el.classList.remove('playing'));
    }

    function stopPlayback() {
      isPlaying = false;
      if (playbackTimeout) {
        clearTimeout(playbackTimeout);
        playbackTimeout = null;
      }

      if (USE_OFFLINE_RENDERING) {
        offlinePlayer.pause();
      } else {
        Tone.Transport.stop();
        Tone.Transport.cancel();
        Tone.Transport.position = 0;
      }

      document.getElementById('playIcon').innerHTML = '<path d="M8 5v14l11-7z"/>';
    }

    function resetPlayback() {
      stopPlayback();
      if (USE_OFFLINE_RENDERING) offlinePlayer.stop();
      currentNoteIndex = 0;
      pausedAt = 0;
      playedSegments = [];
      updateTimeline();
      updateTimeDisplay();
      drawVisualization();

      document.querySelectorAll('.note-item.playing').forEach(el => el.classList.remove('playing'));
    }

    // ========== EVENT HANDLERS ==========
    // Timeline seeking (click and drag)
    const timeline = document.getElementById('timeline');
    let isDragging = false;
    let hasSeeked = false;  // track if user has seeked

    function seekToPosition(e) {
      const rect = timeline.getBoundingClientRect();
      const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const noteIndex = Math.floor(percent * allNotes.length);

      // Stop current playback
      if (isPlaying) {
        stopPlayback();
      }

      // Update position
      currentNoteIndex = noteIndex;
      hasSeeked = true;
      playedSegments = allNotes.slice(0, noteIndex).map((n, idx) => ({ note: n, index: idx }));

      // Update offline player position (if using offline mode)
      if (USE_OFFLINE_RENDERING) {
        const totalDuration = baseDuration / playbackSpeed;
        offlinePlayer.pausedAt = (noteIndex / allNotes.length) * totalDuration;
      }

      updateTimeline();
      drawVisualization();

      // Update highlighted note in panel
      document.querySelectorAll('.note-item.playing').forEach(el => el.classList.remove('playing'));
      const noteItem = document.querySelector(`.note-item[data-index="${noteIndex}"]`);
      if (noteItem) {
        noteItem.classList.add('playing');
        scrollNoteIntoView(noteItem, false);
      }
    }

    timeline.addEventListener('mousedown', (e) => {
      isDragging = true;
      seekToPosition(e);
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        seekToPosition(e);
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    function addSegmentMarkers() {
      const timeline = document.getElementById('timeline');
      timeline.querySelectorAll('.segment-marker').forEach(m => m.remove());

      if (allNotes.length === 0) return;

      const segments = ['A1', 'A2', 'A3', 'A4', 'U1', 'U2', 'M1', 'M2'];
      let noteCount = 0;

      for (const seg of segments) {
        if (parsedGroups[seg] && noteCount > 0) {
          const percent = (noteCount / allNotes.length) * 100;
          const marker = document.createElement('div');
          marker.className = 'segment-marker';
          marker.style.left = `${percent}%`;
          marker.dataset.label = seg;
          timeline.appendChild(marker);
        }
        if (parsedGroups[seg]) {
          noteCount += parsedGroups[seg].length;
        }
      }
    }

    document.getElementById('playBtn').addEventListener('click', async () => {
      await Tone.start();
      if (isPlaying) {
        stopPlayback();
      } else {
        startPlayback();
      }
    });

    document.getElementById('speedSelect').addEventListener('change', (e) => {
      playbackSpeed = parseFloat(e.target.value);
      updateTimeDisplay();
      invalidateRender(); // Speed affects duration, need to re-render
    });

    document.getElementById('volumeSlider').addEventListener('input', (e) => {
      volume = (e.target.value / 100) * 48 - 24; // Map 0-100 to -24 to +24 dB
      invalidateRender(); // Volume is baked into render
    });

    // Play a preview tone for tuning (sounds like mdl/sld voice)
    let tuningTone = null;
    let tuningEffects = [];
    let tuningDebounceTimer = null;

    function playTuningPreview(semitones) {
      // Debounce: wait for user to pause before playing
      if (tuningDebounceTimer) {
        clearTimeout(tuningDebounceTimer);
      }
      tuningDebounceTimer = setTimeout(() => {
        doPlayTuningPreview(semitones);
      }, 150);
    }

    async function doPlayTuningPreview(semitones) {
      await Tone.start();

      // Stop any existing preview
      if (tuningTone) {
        tuningTone.dispose();
        tuningTone = null;
      }
      tuningEffects.forEach(e => e.dispose());
      tuningEffects = [];

      // Calculate frequency: C4 = 261.63 Hz, shifted by semitones
      const freq = 261.63 * Math.pow(2, semitones / 12);

      // Use FMSynth similar to tlk/mdl/sld voice
      tuningTone = new Tone.FMSynth({
        harmonicity: 2,
        modulationIndex: 6,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.15, decay: 0.1, sustain: 0.6, release: 0.3 },
        modulation: { type: 'triangle' },
        modulationEnvelope: { attack: 0.1, decay: 0.1, sustain: 0.4, release: 0.3 }
      });

      // Modal gain boost
      const gain = new Tone.Gain(1.5);
      tuningEffects.push(gain);

      tuningTone.chain(gain, Tone.Destination);
      tuningTone.volume.value = volume - 12; // quieter than main playback
      tuningTone.triggerAttackRelease(freq, 0.4);

      // Clean up after note finishes
      setTimeout(() => {
        if (tuningTone) {
          tuningTone.dispose();
          tuningTone = null;
        }
        tuningEffects.forEach(e => e.dispose());
        tuningEffects = [];
      }, 600);
    }

    document.getElementById('tuningSlider').addEventListener('input', (e) => {
      const semitones = parseFloat(e.target.value);
      setTuning(semitones);
      // Re-parse notes with new tuning and redraw (Hz shown on canvas)
      document.getElementById('presetSelect').dispatchEvent(new Event('change'));
      // Play preview tone
      playTuningPreview(semitones);
    });

    document.getElementById('presetSelect').addEventListener('change', (e) => {
      resetPlayback();
      const preset = e.target.value;
      // Use the shared engine's parseOMInput function
      parsedGroups = parseOMInput(OM_PRESETS[preset]);

      allNotes = [];
      const groupOrder = ['A1', 'A2', 'A3', 'A4', 'U1', 'U2', 'M1', 'M2'];
      for (const g of groupOrder) {
        if (parsedGroups[g]) allNotes.push(...parsedGroups[g]);
      }

      // Show full graph immediately
      playedSegments = allNotes.map((n, idx) => ({ note: n, index: idx }));

      renderNotesPanel();
      addSegmentMarkers();
      drawVisualization();
      updateTimeDisplay();
      invalidateRender(); // New notes, need to re-render

      // Scroll notes panel to top
      const notesPanelContent = document.getElementById('notesPanelContent');
      if (notesPanelContent) notesPanelContent.scrollTop = 0;
    });

    // ========== INIT ==========
    window.addEventListener('resize', resizeCanvas);

    // Initialize
    document.getElementById('presetSelect').dispatchEvent(new Event('change'));
    setTimeout(resizeCanvas, 0);
  </script>
</body>
</html>
